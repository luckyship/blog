---
title: 实现前端路由
tags:
  - 整理
copyright: true
comments: true
date: 2018-11-24 11:44:48
categories: 知识
photos:
top: 122
---

现代的前端框架react/vue/angular都有路由router的概念，通过手写实现可以帮助我们更好地了解它的工作原理。

### 实现路由的2种方式
1. hash模式
2. history模式

### 缺点
hash: 地址栏会多出一个#号，对url造成影响，在某些场景下如微信支付有坑。
history: 兼容性差，直接访问汇报400，需要服务器做处理。

### 基本原理
hash基于hashchange，而history则基于pushState和popState

### hash模式
```javascript
<html>
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #login, #index {
      width: 100%;
      height: 100%;
      display: none;
    }

    #login {
      background: #f5f5f5;
      display: block;
    }

    #index {
      background: #aaddff;
    }
  </style>
</head>
<body>

<!--登录页-->
<div id="login" class="component">
  <input type="button" onclick="hashPush('index?id=1')" value="登陆">
</div>

<!--首页-->
<div id="index" class="component">
  <input type="button" onclick="hashPush('login?key=2',{data:'params data'})" value="退出登陆">
</div>

</body>
<script>
  // 全局变量
  var params = {}

  // 页面跳转
  function hashPush(url, param) {
    location.hash = "#" + url

    // 解析url
    let questionIndex = url.indexOf("?")
    let path = url
    if (questionIndex >= 0) {
      path = url.substr(0, questionIndex)
    }

    if (param) {
      params[path] = param
    }
  }

  // 监听hash的变动
  window.addEventListener('hashchange', function (e) {
    let url = location.hash.slice(1) || "index"
    // 解析url
    let questionIndex = url.indexOf("?")
    let path, query
    if (questionIndex >= 0) {
      path = url.substr(0, questionIndex)
      let queryString = url.substr(questionIndex + 1)
      let queryArray = queryString.split("&")
      let queryObject = {}
      queryArray.map(str => {
        let equalIndex = str.indexOf("=")
        if (equalIndex > 0) {
          let key = str.substr(0, equalIndex)
          let value = str.substr(equalIndex + 1)
          queryObject[key] = value
        }
      })
      query = queryObject
    } else {
      path = url
      query = {}
    }

    console.log('接收到url传递的参数', query)
    console.log('直接用params传递的参数', params[path])
    setVisible(path)
  })

  // 显示跟路由地址对应的内容，隐藏其他内容
  function setVisible(url) {
    let components = Array.from(document.body.querySelectorAll(".component"))
    components.map(item => {
      if (item.id === url) {
        // console.log('显示',item.id)
        item.style.display = 'block'
      } else {
        // console.log('隐藏',item.id)
        item.style.display = 'none'
      }

    })
  }
</script>
</html>
```

### history模式(需要服务器环境)
```javascript
<html>
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #login, #index {
      width: 100%;
      height: 100%;
      display: none;
    }

    #login {
      background: #f5f5f5;
      display: block;
    }

    #index {
      background: #aaddff;
    }
  </style>
</head>
<body>

<!--登录页-->
<div id="login" class="component">
  <input type="button" onclick="historyPush('index')" value="登陆">
</div>

<!--首页-->
<div id="index" class="component">
  <input type="button" onclick="historyPush('login',{data:'params data'})" value="退出登陆">
</div>

</body>
<script>
  // 全局变量
  var params = {}

  // 页面跳转
  function historyPush(url, param) {
    history.pushState(param, '我是页面标题', url)
    if (param) {
      params[url] = param
    }
  }

  // 监听前进后退
  window.addEventListener('popstate', function (e) {
    // e.state 就是pushState 的时候，传的第一个参数
    let url = state.target.location.pathName
    console.log('接收到传递的参数', e.state)
    console.log('直接用params传递的参数', params[path])
    setVisible(path)
  })

  // 显示跟路由地址对应的内容，隐藏其他内容
  function setVisible(url) {
    let components = Array.from(document.body.querySelectorAll(".component"))
    components.map(item => {
      if (item.id === url) {
        // console.log('显示',item.id)
        item.style.display = 'block'
      } else {
        // console.log('隐藏',item.id)
        item.style.display = 'none'
      }

    })
  }
</script>
</html>
```