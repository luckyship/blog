---
title: JavaScript性能优化
date: 2018-08-30 00:17:32
tags:
  - 性能优化
categories: JS
---

### 评估局部变量
主要针对IE而言，由于局部变量的查找是从最特定作用域到最大作用域，且可以通过多个域
层级，所以这种查找会导致查询到通用的结果。在定义函数作用域的时候，如果一个局部变
量在之前没有进行过var变量声明， 那么此处一定要在变量名前加上var关键字以定义其当
前的作用域和防止查询，从而提高代码的速度。

---
<!--more-->

### 除非必要，否则不要使用嵌套循环
减少不必要的循环，例如 for 和 while 循环，以保持 JavaScript 的线性，并避免需要遍历数千个对象。无用的循环可能会导致浏览器处理代码时更困难，从而减缓速度。

### 缓存对象以提高性能
很多时候，会重复使用脚本来访问某个对象。 将重复访问的对象存储在用户定义的变量中，并且之后在引用该对象时使用此变量，可以立刻实现性能提升。

### 使用.js文件来缓存脚本
使用这种技术可以实现性能提升，因为它允许浏览器只加载脚本一次，当页面被重新加载或重新访问时只需要从缓存中调用脚本即可。

### 使用Gzip压缩文件
使用 GZip 可以明显地降低 JavaScript 文件的大小，节省带宽，并加快响应时间。 有时 JavaScript 文件非常大，如果没有经过压缩，它可能会造成网站瘫痪。较小的文件能提供更快、更令人满意的网页体验。

### 尽量减少对HTTP的请求
通过结合外部文件和直接在 XHTML 页面中嵌入 JavaScript 来尽量减少对 HTTP 返回页面的请求。 每一个特定的 HTTP 请求传输至服务器端都会导致大量的时延。

### 不要重复使用相同的脚本
复的脚本对性能会造成显著的影响。重复的脚本会创建不需要的HTTP请求，尤其是在IE浏览器中。在HTML页面中使用脚本标签，可以帮助避免意外地生成重复的脚本。

### 缩短作用域链
全局作用域通常较慢，因为每次执行函数的时候，它会引发创建一个临时的调用作用域，JavaScript 会在作用域链中搜索第一个对象，如果找不到该变量，则会遍历链直到搜索到全局对象。

### 使用函数内联
函数内联有助于减少函数调用的成本，并用被调用的函数体替换函数调用。 在 JavaScript 中执行函数调用是一个高成本的操作，因为需要执行几个准备步骤：为参数分配空间，复制参数以及解析函数名称。

### 尽量不要使用全局变量
由于脚本引擎需要搜索作用域，所以当从函数内部或其他作用域内引用全局变量时，如果局部作用域丢失，全局变量将被销毁。如果全局作用域中的变量并不一直存在于脚本的生命周期，则可以提升性能。

### 不要一直保留对其他文档的引用
当脚本结束后不再保留对其他文档的引用可以实现更快的性能。因为对其他文档中的对象进行的任何引用不会被保存在整个 DOM 树中，并且脚本环境也不会一直保留在内存中。 因此文档本身不用再被加载。

### 不要误用 for-in Object.hasOwnProperty()只遍历当前对象
由于“for-in”循环需要脚本引擎构建包含所有可枚举属性的列表，因此 for 循环内的代码是不会修改这个列表的。 在 for 循环内部，预先计算出列表的长度并赋给变量 len，然后进行迭代。

![optimize](http://cdn.mydearest.cn/blog/images/optimize.png)

## 资源合并压缩 减少HTTP请求
### 尽量合并和压缩html css和js文件 借助前端工具 例如 webpack gulp grunt...
### 开启gzip压缩


## 图片优化
### 雪碧图 图片压缩 svg base64


## 懒加载 / 预加载
### 懒加载：图片进入可视区域之后请求图片资源 对于电商等图片很多，页面很长的业务场景适用 并发加载的资源过多会阻塞 js 的加载，影响网站的正常使用
### 预加载：图片等静态资源在使用之前的提前请求 资源使用到时能从缓存中加载，提升用户体验

## 浏览器存储
### localStorage：大小为 5M 左右仅在客户端使用，不和服务端进行通信 浏览器本地缓存方案
### indexedDB：用于客户端存储大量结构化数据 为应用创建离线版本

## 浏览器缓存
### 强缓存：

- expires：
缓存过期时间，用来指定资源到期的时间，是服务器端的绝对时间
告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求

- cache-control：max-age = xxx
声明该资源在加载后的xxx秒内都直接使用缓存 使用的是相对时间 即加载文件本机的时间

如果在Cache-Control响应头设置了 "max-age" 或者 "s-max-age" 指令，那么 Expires 头会被忽略。


### 协商缓存：

> 触发条件

> Cache-Control 的值为 no-cache （不强缓存）
> max-age 过期了 （强缓存，但总有过期的时候）

- Last-Modified / If-Modified-Since

Last-Modified ------- response header
If-Modified-Since ------- request header
缺点：某些服务端不能获取精确的修改时间；文件修改时间改了，但文件内容却没有变

- Etag / If-None-Match

文件内容的 hash 值
etag ------- response header
if-none-match ------- request header

## CDN 内容分发网络

## 前端错误监控以及上报
- 前端错误分类：

1. 即时运行错误：代码错误
2. 资源加载错误
3. 对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性，并且服务器添加Access-Control-Allow-Origin

- 即时运行错误捕获
（1）try ....catch
（2) window.onerror 或者 window.addEventListener 记住事件捕获阶段获得，不是冒泡阶段


- 资源加载错误
（1）object.onerror，如img.onerror
（2）performance.getEntries （getEntries api返回一个资源加载完成数组，假设为img，再查询页面中一共有多少个img，二者的差就是没有加载上的资源）
（3）Error事件捕获

4. 错误如何上报
- ajax
- image的src上报
```js
(new Image()).src = '错误上报的请求地址'
```

一般来说都是采用image对象的方式上报错误的；使用图片发送get请求，上报信息，由于浏览器对图片有缓存，同样的请求，图片只会发送一次，避免重复上
报。
