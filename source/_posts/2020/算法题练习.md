---
title: 算法题练习
tags:
  - 算法
copyright: true
comments: true
date: 2020-04-23 01:03:40
categories: JS
photos:
---

# 五大算法
- 贪心算法：局部最优解法
- 分治算法：分成多个小模块，与原问题性质相同
- 动态规划：每个状态都是过去历史的一个总结
- 回溯法：发现原先选择不优时，退回重新选择
- 分支限界法：按广度优先策略搜索问题的解空间树，适合求解最优化问题

## 数据树
- 二叉树: 最多只有两个子节点
  - 完全二叉树
    - 若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都连续集中在最左边
  - 满二叉树
    - 深度为 h, 有 n 个节点，且满足 n = 2^h - 1
  - 平衡二叉树
    - 它或者是一颗空树，或它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树
  - 最优二叉树(哈夫曼树)
    - 树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

- 二叉查找树: 是一种特殊的二叉树，能有效地提高查找效率
  - 小值在左，大值在右
  - 节点 n 的所有左子树值小于 n，所有右子树值大于 n

![binary-search-tree](http://cdn.mydearest.cn/blog/images/binary-search-tree.png)

- 遍历节点
  - 前序遍历
    - 根节点
    - 访问左子节点，回到 1
    - 访问右子节点，回到 1
  - 中序遍历
    - 先访问到最左的子节点
    - 访问该节点的父节点
    - 访问该父节点的右子节点， 回到 1
  - 后序遍历
    - 先访问到最左的子节点
    - 访问相邻的右节点
    - 访问父节点， 回到 1

DLR--前序遍历（根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面 ）

![dlr](http://cdn.mydearest.cn/blog/images/dlr.png)

LDR--中序遍历（根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）

![ldr](http://cdn.mydearest.cn/blog/images/ldr.png)

LRD--后序遍历（根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面）

![lrd](http://cdn.mydearest.cn/blog/images/lrd.png)

- 插入与删除节点

---
<!--more-->

## 写出一个方法输出1-100内的所有素数
解析：
由素数（质数）定义可知：

- ① 0、1都不是质数，那么最小的质数就是2。
- ② 除了1和它自身，不能被其他数整除，那么代码表达式表示为：

```js
i % j === 0
```
- 代码实现

```js
function fn() {
  const arr = []
  for (let i = 2; i <= 100; i++) {
    let bl = false
    for (let j = 2; j <= i; j++) {
      if (i === j) continue
      i % j === 0 && (bl = true)
    }
    !bl && arr.push(i)
  }
  return arr
}
console.log(fn()) 
```

## 给定一个整数数组，实现快速排序算法进行升序排列。如[2, 5, 8, 9, 3] =>[2, 3, 5, 8, 9]
解析：（分治法）
将一个列表分割为左右两块，然后再将字列表再进行分割为左右两块，如何反复，知道子元素长度为1时，结束！
- 代码实现
```js
function qSort(arr) {
  if (arr.length <= 1) return arr
  const index = Math.floor(arr.length / 2)
  const midVal = arr.splice(index, 1)[0]
  const left = [],
    right = []
  arr.forEach(item => {
    if (item < midVal) left.push(item)
    else right.push(item)
  })
  return [...qSort(left), midVal, ...qSort(right)]
}
qSort([2, 5, 8, 9, 3])
```

## 求一个字符串中最长的非重复连续子串
```js
function find(s) {
    var str = '';//存放当前最大无重复项字符串
    var len = 0;//存放当前最大无重复项字符串长度
    for(var i=0;i<s.length;i++){
        var char = s.charAt(i);
        var index = str.indexOf(char);
        if(index === -1){  //遍历s将元素挨个放入到str中，每放入一次判断str中是否有重复项
            str += char;
            len = len<str.length?str.length:len;//记录最大长度项,每次重新记录str进行判断，是否大于上次一次最大项
        }
        else{
            str = str.substr(index + 1) + char; //从当前重复项开始重新记录str
        }
    }
    return len;
}
// 'adasdddddddfghti' 6
```

## 求字符串数组的最长公共前缀
> 比如输入: ["flower","flow","flight"]，输出: "fl"

```js
var longestCommonPrefix = function(strs) {
    if (strs === null || strs.length === 0) return "";
    if(strs.length === 1) return strs[0]
    let min = 0, max = 0
    for(let i = 1; i < strs.length; i++) {
        if(strs[min] > strs[i]) min = i
        if(strs[max] < strs[i]) max = i
    }
    for(let j = 0; j < strs[min].length; j++) {
        if(strs[min].charAt(j) !== strs[max].charAt(j)) {
            return strs[min].substring(0, j)
        }
    }
    return strs[min]
};
```

## 实现二叉树(构建、遍历)
```js
function TreeCode() {
    let BiTree = function (ele) {
        this.data = ele;
        this.lChild = null;
        this.rChild = null;
    }

    this.createTree = function () {
        let biTree = new BiTree('A');
        biTree.lChild = new BiTree('B');
        biTree.rChild = new BiTree('C');
        biTree.lChild.lChild = new BiTree('D');
        biTree.lChild.lChild.lChild = new BiTree('G');
        biTree.lChild.lChild.rChild = new BiTree('H');
        biTree.rChild.lChild = new BiTree('E');
        biTree.rChild.rChild = new BiTree('F');
        biTree.rChild.lChild.rChild = new BiTree('I');
        return biTree;
    }
}

//前序遍历
function ProOrderTraverse(biTree) {
    if (biTree == null) return;
    console.log(biTree.data);
    ProOrderTraverse(biTree.lChild);
    ProOrderTraverse(biTree.rChild);
}

//中序遍历
function InOrderTraverse(biTree) {
    if (biTree == null) return;
    InOrderTraverse(biTree.lChild);
    console.log(biTree.data);
    InOrderTraverse(biTree.rChild);
}

//后续遍历
function PostOrderTraverse(biTree) {
    if (biTree == null) return;
    PostOrderTraverse(biTree.lChild);
    PostOrderTraverse(biTree.rChild);
    console.log(biTree.data);
}

let myTree = new TreeCode();
console.log(myTree.createTree());
console.log('前序遍历')
ProOrderTraverse(myTree.createTree());
console.log('中序遍历')
InOrderTraverse(myTree.createTree());
console.log('后续遍历')
PostOrderTraverse(myTree.createTree());
```

## 二叉树的非递归遍历
### 深度优先非递归(栈的先进后出)
```js
function DepthFirstSearch(biTree) {
    let stack = [];
    stack.push(biTree);

    while (stack.length != 0) {
        let node = stack.pop();
        console.log(node.data);
        if (node.rChild) {
            stack.push(node.rChild);
        }
        if (node.lChild) {
            stack.push(node.lChild);
        }

    }

}
```

### 广度优先非递归(队列的先进先出)
```bash
function BreadthFirstSearch(biTree) {
    let queue = [];
    queue.push(biTree);
    while (queue.length != 0) {
        let node = queue.shift();
        console.log(node.data);
        if (node.lChild) {
            queue.push(node.lChild);
        }
        if (node.rChild) {
            queue.push(node.rChild);
        }
    }

}
```
